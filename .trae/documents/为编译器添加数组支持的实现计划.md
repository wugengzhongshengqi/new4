## 目标
- 在现有编译器前端/中间表示/后端中添加对静态定长、任意维度数组的完整支持：声明、读写、表达式索引与多维线性化寻址。

## 范围与约束
- 支持元素类型为 `int` 与 `char`；数组尺寸为编译期常量；索引是运行期表达式。
- 不实现数组初始化语法、边界检查或动态尺寸；传参以元素或地址传递（`&a[i]`），不支持以数组类型作为形式参数。

## 语法改动（mini.y）
- 变量声明（在 `mini.y:80-98` 的 `variable_list`）：
  - 一维：`IDENTIFIER '[' INTEGER ']'` 与列表形式 `variable_list ',' IDENTIFIER '[' INTEGER ']'`。
  - 任意维度：引入 `array_dim_list`，形如 `IDENTIFIER array_dim_list`，`array_dim_list` 递归收集 `[' INTEGER ']` 若干次。
- 赋值语句（`mini.y:187-197`）：
  - `IDENTIFIER index_list '=' expression`，其中 `index_list` 为若干 `[' expression ']`。
- 表达式（`mini.y:199-278`）：
  - `IDENTIFIER index_list` 作为 rvalue，返回元素表达式。
- 词法（mini.l）无需改动；`'['`、`']'` 作为单字符已返回（`mini.l:73`）。

## 符号与类型模型（tac.h）
- 继续使用 `SYM`（`tac.h:60-80`），`type=SYM_VAR`，`dtype` 表示元素类型（`DT_INT/DT_CHAR`）。
- 新增 `ARRINFO` 结构并挂载到 `SYM->etc`：`dimc`、`int *dims`、`int *stride`、`int esize`、`int total`。
  - `esize = 4`（int）或 `1`（char）；`stride[k] = esize * Π(dims[k+1..])`；`total = esize * Π(dims)`。
- 新增接口：`TAC *declare_arr_var(char *name, int *dims, int dimc);`

## 中间代码构造（tac.c）
- 数组声明：实现 `declare_arr_var`，创建 `SYM`、计算并填充 `ARRINFO`，生成 `TAC_VAR`。
- 索引读写：新增任意维度的辅助函数，复用现有指针与算术 TAC：
  - `EXP *do_index_read_nd(SYM *arr, EXP **idxs, int n)`：
    - 线性化偏移：`off = Σ(idx[k] * stride[k])`；`p = &arr + off`；根据元素类型设置指针临时的 `dtype`（`DT_PTR_CHAR/DT_PTR_INT`）；`ret = *p`。
  - `TAC *do_index_write_nd(SYM *arr, EXP **idxs, int n, EXP *val)`：同上地址计算后生成 `TAC_DEREF_W`。
  - 仅使用现有 `TAC_VAR/TAC_MUL/TAC_ADD/TAC_ADDR/TAC_DEREF_R/TAC_DEREF_W/join_tac/mk_tmp`，不增加新操作码。
- 语义动作：在上述 `index_list` 位置将表达式列表收集为 `EXP **`，调用 `_nd` 实现读/写。

## 代码生成（obj.c）
- 在 `TAC_VAR` 分支（`obj.c:503-516`）按 `ARRINFO.total` 分配字节：
  - 局部：`c->a->offset = tof; tof += total;`
  - 全局：`c->a->offset = tos; tos += total;`
- 地址计算与读写已由现有后端实现：
  - `TAC_ADDR` 生成基址（`obj.c:527-547`）；
  - 通过 `TAC_ADD` 累加偏移；
  - `TAC_DEREF_R/W` 按指针 `dtype` 选择字节/字（`obj.c:549-571`）。

## 校验与错误处理
- 声明阶段：确保各维 `INTEGER` > 0；计算溢出时报告错误。
- 索引阶段：校验索引维度数量与数组维度匹配；索引类型要求为整型表达式；不做运行期越界检查。

## 测试与验证
- 一维：`int a[4]; a[0]=1; output a[0];`。
- 多维：`int m[2][3][4]; m[1][2][3]=7; output m[1][2][3];`。
- 指针交互：`int a[4]; int *p; p=&a[2]; output *p;`。
- 检查生成的 TAC 注释与目标代码是否出现 `ADDR/MUL/ADD/DEREF_*` 序列；验证 `STATIC/STACK` 区分配是否按 `total` 累计。

## 关键改动位置
- `mini.y`：声明/赋值/表达式语法扩展（`mini.y:80-98`, `mini.y:187-197`, `mini.y:199-278`）。
- `tac.h`：`ARRINFO` 与 `declare_arr_var` 原型（`tac.h:13-18`, `tac.h:60-80`, `tac.h:111-159`）。
- `tac.c`：数组声明与任意维度索引构造（参考指针实现 `tac.c:772-812`）。
- `obj.c`：`TAC_VAR` 分支的字节数分配（`obj.c:503-516`）。

## 交付物
- 更新的源文件：`tac.h/tac.c/mini.y/obj.c`；
- 新测试用例：覆盖一维与多维索引、指针交互；
- 编译运行方式与现有工程一致。